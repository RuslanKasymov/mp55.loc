<?php return array (
  'unique_key' => 'category',
  'preserve_keys' => false,
  'update_object' => true,
  'related_objects' => 
  array (
    'Snippets' => 
    array (
      '331e14549357415fdbbbaba9a26e98fa' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"typography","description":"Create beautifully typeset content in MODX without the extra work.","editor_type":0,"category":0,"cache_type":0,"snippet":"$output = $input;\\n\\n#\\n# SmartyPants  -  Smart punctuation for web sites\\n#\\n# PHP SmartyPants  \\n# Copyright (c) 2004-2006 Michel Fortin\\n# <http:\\/\\/www.michelf.com\\/>\\n#\\n# Original SmartyPants\\n# Copyright (c) 2003-2004 John Gruber\\n# <http:\\/\\/daringfireball.net>\\n#\\n\\n\\nif (!defined(\'SMARTYPANTS_VERSION\')) define( \'SMARTYPANTS_VERSION\',  \\"1.5.1f\\" ); # Unreleased\\n\\n\\n#\\n# Default configuration:\\n#\\n#  1  ->  \\"--\\" for em-dashes; no en-dash support  \\n#  2  ->  \\"---\\" for em-dashes; \\"--\\" for en-dashes  \\n#  3  ->  \\"--\\" for em-dashes; \\"---\\" for en-dashes  \\n#  See docs for more configuration options.\\n#\\nif (!defined(\'SMARTYPANTS_ATTR\')) define( \'SMARTYPANTS_ATTR\',    2 );\\n\\n\\n# SmartyPants will not alter the content of these tags:\\nif (!defined(\'SMARTYPANTS_TAGS_TO_SKIP\')) define( \'SMARTYPANTS_TAGS_TO_SKIP\', \'pre|code|kbd|script|style|math\');\\n\\n\\n### Standard Function Interface ###\\n\\nif (!defined(\'SMARTYPANTS_PARSER_CLASS\')) define( \'SMARTYPANTS_PARSER_CLASS\', \'SmartyPants_Parser\' );\\n\\nif (!function_exists(\'SmartyPants\')) {\\n    function SmartyPants($text, $attr = SMARTYPANTS_ATTR) {\\n    #\\n    # Initialize the parser and return the result of its transform method.\\n    #\\n        # Setup static parser array.\\n        static $parser = array();\\n        if (!isset($parser[$attr])) {\\n            $parser_class = SMARTYPANTS_PARSER_CLASS;\\n            $parser[$attr] = new $parser_class($attr);\\n        }\\n    \\n        # Transform text using parser.\\n        return $parser[$attr]->transform($text);\\n    }\\n}\\n\\nif (!function_exists(\'SmartQuotes\')) {\\n    function SmartQuotes($text, $attr = null) {\\n        switch ($attr) {\\n            case 0:  return $text;\\n            case 2:  $attr = \'qb\'; break;\\n            default: $attr = \'q\'; break;\\n        }\\n        return SmartyPants($text, $attr);\\n    }\\n}\\n\\nif (!function_exists(\'SmartDashes\')) {\\n    function SmartDashes($text, $attr = null) {\\n        switch ($attr) {\\n            case 0:  return $text;\\n            case 2:  $attr = \'D\'; break;\\n            case 3:  $attr = \'i\'; break;\\n            default: $attr = \'d\'; break;\\n        }\\n        return SmartyPants($text, $attr);\\n    }\\n}\\n\\nif (!function_exists(\'SmartElipsis\')) {\\n    function SmartElipsis($text, $attr = null) {\\n        switch ($attr) {\\n            case 0:  return $text;\\n            default: $attr = \'e\'; break;\\n        }\\n        return SmartyPants($text, $attr);\\n    }\\n}\\n\\n\\nif (!function_exists(\'SmartSymbols\')) {\\n    function SmartSymbols($text, $attr = null) {\\n        switch ($attr) {\\n            case 0:  return $text;\\n            default: $attr = \'s\'; break;\\n        }\\n        return SmartyPants($text, $attr);\\n    }\\n}\\n\\n\\nif (!class_exists(\'SmartyPants_Parser\')) {\\n    #\\n    # SmartyPants Parser\\n    #\\n    \\n    class SmartyPants_Parser {\\n    \\n        # Options to specify which transformations to make:\\n        var $do_nothing   = 0;\\n        var $do_quotes    = 0;\\n        var $do_backticks = 0;\\n        var $do_dashes    = 0;\\n        var $do_ellipses  = 0;\\n        var $do_stupefy   = 0;\\n        var $convert_quot = 0; # should we translate &quot; entities into normal quotes?\\n    \\n        function SmartyPants_Parser($attr = SMARTYPANTS_ATTR) {\\n        #\\n        # Initialize a SmartyPants_Parser with certain attributes.\\n        #\\n        # Parser attributes:\\n        # 0 : do nothing\\n        # 1 : set all\\n        # 2 : set all, using old school en- and em- dash shortcuts\\n        # 3 : set all, using inverted old school en and em- dash shortcuts\\n        # \\n        # q : quotes\\n        # b : backtick quotes (``double\'\' only)\\n        # B : backtick quotes (``double\'\' and `single\')\\n        # d : dashes\\n        # D : old school dashes\\n        # i : inverted old school dashes\\n        # e : ellipses\\n        # s : symbols\\n        # w : convert &quot; entities to \\" for Dreamweaver users\\n        #\\n            if ($attr == \\"0\\") {\\n                $this->do_nothing   = 1;\\n            }\\n            else if ($attr == \\"1\\") {\\n                # Do everything, turn all options on.\\n                $this->do_quotes    = 1;\\n                $this->do_backticks = 1;\\n                $this->do_dashes    = 1;\\n                $this->do_ellipses  = 1;\\n                $this->do_symbols   = 1;\\n            }\\n            else if ($attr == \\"2\\") {\\n                # Do everything, turn all options on, use old school dash shorthand.\\n                $this->do_quotes    = 1;\\n                $this->do_backticks = 1;\\n                $this->do_dashes    = 2;\\n                $this->do_ellipses  = 1;\\n                $this->do_symbols   = 1;\\n            }\\n            else if ($attr == \\"3\\") {\\n                # Do everything, turn all options on, use inverted old school dash shorthand.\\n                $this->do_quotes    = 1;\\n                $this->do_backticks = 1;\\n                $this->do_dashes    = 3;\\n                $this->do_ellipses  = 1;\\n                $this->do_symbols   = 1;\\n            }\\n            else if ($attr == \\"-1\\") {\\n                # Special \\"stupefy\\" mode.\\n                $this->do_stupefy   = 1;\\n            }\\n            else {\\n                $chars = preg_split(\'\\/\\/\', $attr);\\n                foreach ($chars as $c){\\n                    if      ($c == \\"q\\") { $this->do_quotes    = 1; }\\n                    else if ($c == \\"b\\") { $this->do_backticks = 1; }\\n                    else if ($c == \\"B\\") { $this->do_backticks = 2; }\\n                    else if ($c == \\"d\\") { $this->do_dashes    = 1; }\\n                    else if ($c == \\"D\\") { $this->do_dashes    = 2; }\\n                    else if ($c == \\"i\\") { $this->do_dashes    = 3; }\\n                    else if ($c == \\"e\\") { $this->do_ellipses  = 1; }\\n                    else if ($c == \\"s\\") { $this->do_symbols   = 1; }\\n                    else if ($c == \\"w\\") { $this->convert_quot = 1; }\\n                    else {\\n                        # Unknown attribute option, ignore.\\n                    }\\n                }\\n            }\\n        }\\n    \\n        function transform($text) {\\n    \\n            if ($this->do_nothing) {\\n                return $text;\\n            }\\n    \\n            $tokens = $this->tokenizeHTML($text);\\n            $result = \'\';\\n            $in_pre = 0;  # Keep track of when we\'re inside <pre> or <code> tags.\\n    \\n            $prev_token_last_char = \\"\\"; # This is a cheat, used to get some context\\n                                        # for one-character tokens that consist of \\n                                        # just a quote char. What we do is remember\\n                                        # the last character of the previous text\\n                                        # token, to use as context to curl single-\\n                                        # character quote tokens correctly.\\n    \\n            foreach ($tokens as $cur_token) {\\n                if ($cur_token[0] == \\"tag\\") {\\n                    # Don\'t mess with quotes inside tags.\\n                    $result .= $cur_token[1];\\n                    if (preg_match(\'@<(\\/?)(?:\'.SMARTYPANTS_TAGS_TO_SKIP.\')[\\\\s>]@\', $cur_token[1], $matches)) {\\n                        $in_pre = isset($matches[1]) && $matches[1] == \'\\/\' ? 0 : 1;\\n                    }\\n                } else {\\n                    $t = $cur_token[1];\\n                    $last_char = substr($t, -1); # Remember last char of this token before processing.\\n                    if (! $in_pre) {\\n                        $t = $this->educate($t, $prev_token_last_char);\\n                    }\\n                    $prev_token_last_char = $last_char;\\n                    $result .= $t;\\n                }\\n            }\\n    \\n            return $result;\\n        }\\n    \\n    \\n        function educate($t, $prev_token_last_char) {\\n            $t = $this->processEscapes($t);\\n    \\n            if ($this->convert_quot) {\\n                $t = preg_replace(\'\\/&quot;\\/\', \'\\"\', $t);\\n            }\\n    \\n            if ($this->do_dashes) {\\n                if ($this->do_dashes == 1) $t = $this->educateDashes($t);\\n                if ($this->do_dashes == 2) $t = $this->educateDashesOldSchool($t);\\n                if ($this->do_dashes == 3) $t = $this->educateDashesOldSchoolInverted($t);\\n            }\\n    \\n            if ($this->do_ellipses) $t = $this->educateEllipses($t);\\n    \\n            if ($this->do_symbols) $t = $this->educateSymbols($t);\\n    \\n            # Note: backticks need to be processed before quotes.\\n            if ($this->do_backticks) {\\n                $t = $this->educateBackticks($t);\\n                if ($this->do_backticks == 2) $t = $this->educateSingleBackticks($t);\\n            }\\n    \\n            if ($this->do_quotes) {\\n                if ($t == \\"\'\\") {\\n                    # Special case: single-character \' token\\n                    if (preg_match(\'\\/\\\\S\\/\', $prev_token_last_char)) {\\n                        $t = \\"&#8217;\\";\\n                    }\\n                    else {\\n                        $t = \\"&#8216;\\";\\n                    }\\n                }\\n                else if ($t == \'\\"\') {\\n                    # Special case: single-character \\" token\\n                    if (preg_match(\'\\/\\\\S\\/\', $prev_token_last_char)) {\\n                        $t = \\"&#8221;\\";\\n                    }\\n                    else {\\n                        $t = \\"&#8220;\\";\\n                    }\\n                }\\n                else {\\n                    # Normal case:\\n                    $t = $this->educateQuotes($t);\\n                }\\n            }\\n    \\n            if ($this->do_stupefy) $t = $this->stupefyEntities($t);\\n            \\n            return $t;\\n        }\\n    \\n    \\n        function educateQuotes($_) {\\n        #\\n        #   Parameter:  String.\\n        #\\n        #   Returns:    The string, with \\"educated\\" curly quote HTML entities.\\n        #\\n        #   Example input:  \\"Isn\'t this fun?\\"\\n        #   Example output: &#8220;Isn&#8217;t this fun?&#8221;\\n        #\\n            # Make our own \\"punctuation\\" character class, because the POSIX-style\\n            # [:PUNCT:] is only available in Perl 5.6 or later:\\n            $punct_class = \\"[!\\\\\\"#\\\\\\\\$\\\\\\\\%\'()*+,-.\\\\\\\\\\/:;<=>?\\\\\\\\@\\\\\\\\[\\\\\\\\\\\\\\\\\\\\]\\\\\\\\^_`{|}~]\\";\\n    \\n            # Special case if the very first character is a quote\\n            # followed by punctuation at a non-word-break. Close the quotes by brute force:\\n            $_ = preg_replace(\\n                array(\\"\\/^\'(?=$punct_class\\\\\\\\B)\\/\\", \\"\\/^\\\\\\"(?=$punct_class\\\\\\\\B)\\/\\"),\\n                array(\'&#8217;\',                 \'&#8221;\'), $_);\\n    \\n    \\n            # Special case for double sets of quotes, e.g.:\\n            #   <p>He said, \\"\'Quoted\' words in a larger quote.\\"<\\/p>\\n            $_ = preg_replace(\\n                array(\\"\\/\\\\\\"\'(?=\\\\w)\\/\\",    \\"\\/\'\\\\\\"(?=\\\\w)\\/\\"),\\n                array(\'&#8220;&#8216;\', \'&#8216;&#8220;\'), $_);\\n    \\n            # Special case for decade abbreviations (the \'80s):\\n            $_ = preg_replace(\\"\\/\'(?=\\\\\\\\d{2}s)\\/\\", \'&#8217;\', $_);\\n    \\n            $close_class = \'[^\\\\ \\\\t\\\\r\\\\n\\\\[\\\\{\\\\(\\\\-]\';\\n            $dec_dashes = \'&\\\\#8211;|&\\\\#8212;\';\\n    \\n            # Get most opening single quotes:\\n            $_ = preg_replace(\\"{\\n                (\\n                    \\\\\\\\s          |   # a whitespace char, or\\n                    &nbsp;      |   # a non-breaking space entity, or\\n                    --          |   # dashes, or\\n                    &[mn]dash;  |   # named dash entities\\n                    $dec_dashes |   # or decimal entities\\n                    &\\\\\\\\#x201[34];    # or hex\\n                )\\n                \'                   # the quote\\n                (?=\\\\\\\\w)              # followed by a word character\\n                }x\\", \'\\\\1&#8216;\', $_);\\n            # Single closing quotes:\\n            $_ = preg_replace(\\"{\\n                ($close_class)?\\n                \'\\n                (?(1)|          # If $1 captured, then do nothing;\\n                  (?=\\\\\\\\s | s\\\\\\\\b)  # otherwise, positive lookahead for a whitespace\\n                )               # char or an \'s\' at a word ending position. This\\n                                # is a special case to handle something like:\\n                                # \\\\\\"<i>Custer<\\/i>\'s Last Stand.\\\\\\"\\n                }xi\\", \'\\\\1&#8217;\', $_);\\n    \\n            # Any remaining single quotes should be opening ones:\\n            $_ = str_replace(\\"\'\\", \'&#8216;\', $_);\\n    \\n    \\n            # Get most opening double quotes:\\n            $_ = preg_replace(\\"{\\n                (\\n                    \\\\\\\\s          |   # a whitespace char, or\\n                    &nbsp;      |   # a non-breaking space entity, or\\n                    --          |   # dashes, or\\n                    &[mn]dash;  |   # named dash entities\\n                    $dec_dashes |   # or decimal entities\\n                    &\\\\\\\\#x201[34];    # or hex\\n                )\\n                \\\\\\"                   # the quote\\n                (?=\\\\\\\\w)              # followed by a word character\\n                }x\\", \'\\\\1&#8220;\', $_);\\n    \\n            # Double closing quotes:\\n            $_ = preg_replace(\\"{\\n                ($close_class)?\\n                \\\\\\"\\n                (?(1)|(?=\\\\\\\\s))   # If $1 captured, then do nothing;\\n                                   # if not, then make sure the next char is whitespace.\\n                }x\\", \'\\\\1&#8221;\', $_);\\n    \\n            # Any remaining quotes should be opening ones.\\n            $_ = str_replace(\'\\"\', \'&#8220;\', $_);\\n    \\n            return $_;\\n        }\\n    \\n    \\n        function educateBackticks($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with ``backticks\'\' -style double quotes\\n        #               translated into HTML curly quote entities.\\n        #\\n        #   Example input:  ``Isn\'t this fun?\'\'\\n        #   Example output: &#8220;Isn\'t this fun?&#8221;\\n        #\\n    \\n            $_ = str_replace(array(\\"``\\",       \\"\'\'\\",),\\n                             array(\'&#8220;\', \'&#8221;\'), $_);\\n            return $_;\\n        }\\n    \\n    \\n        function educateSingleBackticks($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with `backticks\' -style single quotes\\n        #               translated into HTML curly quote entities.\\n        #\\n        #   Example input:  `Isn\'t this fun?\'\\n        #   Example output: &#8216;Isn&#8217;t this fun?&#8217;\\n        #\\n    \\n            $_ = str_replace(array(\\"`\\",       \\"\'\\",),\\n                             array(\'&#8216;\', \'&#8217;\'), $_);\\n            return $_;\\n        }\\n    \\n    \\n        function educateDashes($_) {\\n        #\\n        #   Parameter:  String.\\n        #\\n        #   Returns:    The string, with each instance of \\"--\\" translated to\\n        #               an em-dash HTML entity.\\n        #\\n    \\n            $_ = str_replace(\'--\', \'&#8212;\', $_);\\n            return $_;\\n        }\\n    \\n    \\n        function educateDashesOldSchool($_) {\\n        #\\n        #   Parameter:  String.\\n        #\\n        #   Returns:    The string, with each instance of \\"--\\" translated to\\n        #               an en-dash HTML entity, and each \\"---\\" translated to\\n        #               an em-dash HTML entity.\\n        #\\n    \\n            #                      em         en\\n            $_ = str_replace(array(\\"---\\",     \\"--\\",),\\n                             array(\'&#8212;\', \'&#8211;\'), $_);\\n            return $_;\\n        }\\n    \\n    \\n        function educateDashesOldSchoolInverted($_) {\\n        #\\n        #   Parameter:  String.\\n        #\\n        #   Returns:    The string, with each instance of \\"--\\" translated to\\n        #               an em-dash HTML entity, and each \\"---\\" translated to\\n        #               an en-dash HTML entity. Two reasons why: First, unlike the\\n        #               en- and em-dash syntax supported by\\n        #               EducateDashesOldSchool(), it\'s compatible with existing\\n        #               entries written before SmartyPants 1.1, back when \\"--\\" was\\n        #               only used for em-dashes.  Second, em-dashes are more\\n        #               common than en-dashes, and so it sort of makes sense that\\n        #               the shortcut should be shorter to type. (Thanks to Aaron\\n        #               Swartz for the idea.)\\n        #\\n    \\n            #                      en         em\\n            $_ = str_replace(array(\\"---\\",     \\"--\\",),\\n                             array(\'&#8211;\', \'&#8212;\'), $_);\\n            return $_;\\n        }\\n    \\n    \\n        function educateEllipses($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with each instance of \\"...\\" translated to\\n        #               an ellipsis HTML entity. Also converts the case where\\n        #               there are spaces between the dots.\\n        #\\n        #   Example input:  Huh...?\\n        #   Example output: Huh&#8230;?\\n        #\\n    \\n            $_ = str_replace(array(\\"...\\",     \\". . .\\",), \'&#8230;\', $_);\\n            return $_;\\n        }\\n\\n\\n        function educateSymbols($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with each instance of \\"(c)\\", \\"(r)\\" and \\"(tm)\\" translated to\\n        #               a \\u00a9, \\u00ae, \\u2122 and \\u00b0 HTML entities.\\n        #\\n        #   Example input:  (c)2015. All rights reserved.\\n        #   Example output: &#169;2015. All rights reserved.\\n        #\\n    \\n            $_ = str_replace(array(\\"(c)\\",   \\"(r)\\",   \\"(tm)\\",    \\"(deg)\\"),\\n                             array(\'&#169;\',\'&#174;\',\'&#8482;\', \'&#176;\'), $_);\\n            return $_;\\n        }\\n    \\n    \\n        function stupefyEntities($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with each SmartyPants HTML entity translated to\\n        #               its ASCII counterpart.\\n        #\\n        #   Example input:  &#8220;Hello &#8212; world.&#8221;\\n        #   Example output: \\"Hello -- world.\\"\\n        #\\n    \\n                                #  en-dash    em-dash\\n            $_ = str_replace(array(\'&#8211;\', \'&#8212;\'),\\n                             array(\'-\',       \'--\'), $_);\\n    \\n            # single quote         open       close\\n            $_ = str_replace(array(\'&#8216;\', \'&#8217;\'), \\"\'\\", $_);\\n    \\n            # double quote         open       close\\n            $_ = str_replace(array(\'&#8220;\', \'&#8221;\'), \'\\"\', $_);\\n    \\n            $_ = str_replace(\'&#8230;\', \'...\', $_); # ellipsis\\n    \\n            return $_;\\n        }\\n    \\n    \\n        function processEscapes($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with after processing the following backslash\\n        #               escape sequences. This is useful if you want to force a \\"dumb\\"\\n        #               quote or other character to appear.\\n        #\\n        #               Escape  Value\\n        #               ------  -----\\n        #               \\\\\\\\      &#92;\\n        #               \\\\\\"      &#34;\\n        #               \\\\\'      &#39;\\n        #               \\\\.      &#46;\\n        #               \\\\-      &#45;\\n        #               \\\\`      &#96;\\n        #\\n            $_ = str_replace(\\n                array(\'\\\\\\\\\\\\\\\\\',  \'\\\\\\"\',    \\"\\\\\'\\",    \'\\\\.\',    \'\\\\-\',    \'\\\\`\'),\\n                array(\'&#92;\', \'&#34;\', \'&#39;\', \'&#46;\', \'&#45;\', \'&#96;\'), $_);\\n    \\n            return $_;\\n        }\\n    \\n    \\n        function tokenizeHTML($str) {\\n        #\\n        #   Parameter:  String containing HTML markup.\\n        #   Returns:    An array of the tokens comprising the input\\n        #               string. Each token is either a tag (possibly with nested,\\n        #               tags contained therein, such as <a href=\\"<MTFoo>\\">, or a\\n        #               run of text between tags. Each element of the array is a\\n        #               two-element array; the first is either \'tag\' or \'text\';\\n        #               the second is the actual value.\\n        #\\n        #\\n        #   Regular expression derived from the _tokenize() subroutine in \\n        #   Brad Choate\'s MTRegex plugin.\\n        #   <http:\\/\\/www.bradchoate.com\\/past\\/mtregex.php>\\n        #\\n            $index = 0;\\n            $tokens = array();\\n    \\n            $match = \'(?s:<!--.*?-->)|\'.    # comment\\n                     \'(?s:<\\\\?.*?\\\\?>)|\'.     # processing instruction\\n                                            # regular tags\\n                     \'(?:<[\\/!$]?[-a-zA-Z0-9:]+\\\\b(?>[^\\"\\\\\'>]+|\\"[^\\"]*\\"|\\\\\'[^\\\\\']*\\\\\')*>)\'; \\n    \\n            $parts = preg_split(\\"{($match)}\\", $str, -1, PREG_SPLIT_DELIM_CAPTURE);\\n    \\n            foreach ($parts as $part) {\\n                if (++$index % 2 && $part != \'\') \\n                    $tokens[] = array(\'text\', $part);\\n                else\\n                    $tokens[] = array(\'tag\', $part);\\n            }\\n            return $tokens;\\n        }\\n    \\n    }\\n}\\n\\n\\n\\/*\\n\\nPHP SmartyPants\\n===============\\n\\nDescription\\n-----------\\n\\nThis is a PHP translation of the original SmartyPants quote educator written in\\nPerl by John Gruber.\\n\\nSmartyPants is a web publishing utility that translates plain ASCII\\npunctuation characters into \\"smart\\" typographic punctuation HTML\\nentities. SmartyPants can perform the following transformations:\\n\\n*   Straight quotes (`\\"` and `\'`) into \\"curly\\" quote HTML entities\\n*   Backticks-style quotes (` ``like this\'\' `) into \\"curly\\" quote HTML \\n    entities\\n*   Dashes (`--` and `---`) into en- and em-dash entities\\n*   Three consecutive dots (`...`) into an ellipsis entity\\n\\nSmartyPants does not modify characters within `<pre>`, `<code>`, `<kbd>`, \\n`<script>`, or `<math>` tag blocks. Typically, these tags are used to \\ndisplay text where smart quotes and other \\"smart punctuation\\" would not \\nbe appropriate, such as source code or example markup.\\n\\n\\n### Backslash Escapes ###\\n\\nIf you need to use literal straight quotes (or plain hyphens and\\nperiods), SmartyPants accepts the following backslash escape sequences\\nto force non-smart punctuation. It does so by transforming the escape\\nsequence into a decimal-encoded HTML entity:\\n\\n    Escape  Value  Character\\n    ------  -----  ---------\\n      \\\\\\\\    &#92;    \\\\\\n      \\\\\\"    &#34;    \\"\\n      \\\\\'    &#39;    \'\\n      \\\\.    &#46;    .\\n      \\\\-    &#45;    -\\n      \\\\`    &#96;    `\\n\\nThis is useful, for example, when you want to use straight quotes as\\nfoot and inch marks: 6\'2\\" tall; a 17\\" iMac.\\n\\n\\nBugs\\n----\\n\\nTo file bug reports or feature requests (other than topics listed in the\\nCaveats section above) please send email to:\\n\\n<michel.fortin@michelf.com>\\n\\nIf the bug involves quotes being curled the wrong way, please send example\\ntext to illustrate.\\n\\n\\n### Algorithmic Shortcomings ###\\n\\nOne situation in which quotes will get curled the wrong way is when\\napostrophes are used at the start of leading contractions. For example:\\n\\n    \'Twas the night before Christmas.\\n\\nIn the case above, SmartyPants will turn the apostrophe into an opening\\nsingle-quote, when in fact it should be a closing one. I don\'t think\\nthis problem can be solved in the general case -- every word processor\\nI\'ve tried gets this wrong as well. In such cases, it\'s best to use the\\nproper HTML entity for closing single-quotes (`&#8217;`) by hand.\\n\\n\\nVersion History\\n---------------\\n\\n1.5.1f (23 Jan 2013):\\n\\n*   Fixed handling of HTML comments to match latest HTML specs instead of\\n    doing it the old SGML way.\\n\\n*   Lowered WordPress filtering priority to avoid clashing with the \\n    [caption] tag filter. Thanks to Mehdi Kabab for the fix.\\n\\n\\n1.5.1oo (19 May 2006)\\n\\n*   Converted SmartyPants to a object-oriented design.\\n\\n\\n1.5.1e (9 Dec 2005)\\n\\n*   Corrected a bug that prevented special characters from being \\n    escaped.\\n\\n\\n1.5.1d (25 May 2005)\\n\\n*   Corrected a small bug in `_TokenizeHTML` where a Doctype declaration\\n    was not seen as HTML (smart quotes where applied inside).\\n\\n\\n1.5.1c (13 Dec 2004)\\n\\n*   Changed a regular expression in `_TokenizeHTML` that could lead to\\n    a segmentation fault with PHP 4.3.8 on Linux.\\n\\n\\n1.5.1b (6 Sep 2004)\\n\\n*   Corrected a problem with quotes immediately following a dash\\n    with no space between: `Text--\\"quoted text\\"--text.`\\n    \\n*   PHP SmartyPants can now be used as a modifier by the Smarty \\n    template engine. Rename the file to \\"modifier.smartypants.php\\"\\n    and put it in your smarty plugins folder.\\n\\n*   Replaced a lot of space characters by tabs, saving about 4 KB.\\n\\n\\n1.5.1a (30 Jun 2004)\\n\\n*   PHP Markdown and PHP Smartypants now share the same `_TokenizeHTML` \\n    function when loaded simultanously.\\n\\n*   Changed the internals of `_TokenizeHTML` to lower the PHP version\\n    requirement to PHP 4.0.5.\\n\\n\\n1.5.1 (6 Jun 2004)\\n\\n*   Initial release of PHP SmartyPants, based on version 1.5.1 of the \\n    original SmartyPants written in Perl.\\n\\n\\nAuthor\\n------\\n\\nOriginal SmartyPants by John Gruber\\n<http:\\/\\/daringfireball.net\\/>\\n\\nPHP Port by Michel Fortin\\n<http:\\/\\/www.michelf.com\\/>\\n\\n\\nAdditional Credits\\n------------------\\n\\nPortions of this plug-in are based on Brad Choate\'s nifty MTRegex plug-in.\\nBrad Choate also contributed a few bits of source code to this plug-in.\\nBrad Choate is a fine hacker indeed. (<http:\\/\\/bradchoate.com\\/>)\\n\\nJeremy Hedley (<http:\\/\\/antipixel.com\\/>) and Charles Wiltgen\\n(<http:\\/\\/playbacktime.com\\/>) deserve mention for exemplary beta testing of \\nthe orignal SmartyPants.\\n\\n\\nCopyright and License\\n---------------------\\n\\nCopyright (c) 2003 John Gruber  \\n<http:\\/\\/daringfireball.net\\/>  \\nAll rights reserved.\\n\\nCopyright (c) 2004-2006 Michel Fortin  \\n<http:\\/\\/www.michelf.com>\\n\\nRedistribution and use in source and binary forms, with or without\\nmodification, are permitted provided that the following conditions are met:\\n\\n*   Redistributions of source code must retain the above copyright\\n    notice, this list of conditions and the following disclaimer.\\n\\n*   Redistributions in binary form must reproduce the above copyright\\n    notice, this list of conditions and the following disclaimer in the\\n    documentation and\\/or other materials provided with the distribution.\\n\\n*   Neither the name \\"SmartyPants\\" nor the names of its contributors may\\n    be used to endorse or promote products derived from this software\\n    without specific prior written permission.\\n\\nThis software is provided by the copyright holders and contributors \\"as is\\"\\nand any express or implied warranties, including, but not limited to, the \\nimplied warranties of merchantability and fitness for a particular purpose \\nare disclaimed. In no event shall the copyright owner or contributors be \\nliable for any direct, indirect, incidental, special, exemplary, or \\nconsequential damages (including, but not limited to, procurement of \\nsubstitute goods or services; loss of use, data, or profits; or business \\ninterruption) however caused and on any theory of liability, whether in \\ncontract, strict liability, or tort (including negligence or otherwise) \\narising in any way out of the use of this software, even if advised of the\\npossibility of such damage.\\n\\n*\\/\\n\\n\\nreturn SmartyPants($output,$attr = SMARTYPANTS_ATTR);","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"$output = $input;\\n\\n#\\n# SmartyPants  -  Smart punctuation for web sites\\n#\\n# PHP SmartyPants  \\n# Copyright (c) 2004-2006 Michel Fortin\\n# <http:\\/\\/www.michelf.com\\/>\\n#\\n# Original SmartyPants\\n# Copyright (c) 2003-2004 John Gruber\\n# <http:\\/\\/daringfireball.net>\\n#\\n\\n\\nif (!defined(\'SMARTYPANTS_VERSION\')) define( \'SMARTYPANTS_VERSION\',  \\"1.5.1f\\" ); # Unreleased\\n\\n\\n#\\n# Default configuration:\\n#\\n#  1  ->  \\"--\\" for em-dashes; no en-dash support  \\n#  2  ->  \\"---\\" for em-dashes; \\"--\\" for en-dashes  \\n#  3  ->  \\"--\\" for em-dashes; \\"---\\" for en-dashes  \\n#  See docs for more configuration options.\\n#\\nif (!defined(\'SMARTYPANTS_ATTR\')) define( \'SMARTYPANTS_ATTR\',    2 );\\n\\n\\n# SmartyPants will not alter the content of these tags:\\nif (!defined(\'SMARTYPANTS_TAGS_TO_SKIP\')) define( \'SMARTYPANTS_TAGS_TO_SKIP\', \'pre|code|kbd|script|style|math\');\\n\\n\\n### Standard Function Interface ###\\n\\nif (!defined(\'SMARTYPANTS_PARSER_CLASS\')) define( \'SMARTYPANTS_PARSER_CLASS\', \'SmartyPants_Parser\' );\\n\\nif (!function_exists(\'SmartyPants\')) {\\n    function SmartyPants($text, $attr = SMARTYPANTS_ATTR) {\\n    #\\n    # Initialize the parser and return the result of its transform method.\\n    #\\n        # Setup static parser array.\\n        static $parser = array();\\n        if (!isset($parser[$attr])) {\\n            $parser_class = SMARTYPANTS_PARSER_CLASS;\\n            $parser[$attr] = new $parser_class($attr);\\n        }\\n    \\n        # Transform text using parser.\\n        return $parser[$attr]->transform($text);\\n    }\\n}\\n\\nif (!function_exists(\'SmartQuotes\')) {\\n    function SmartQuotes($text, $attr = null) {\\n        switch ($attr) {\\n            case 0:  return $text;\\n            case 2:  $attr = \'qb\'; break;\\n            default: $attr = \'q\'; break;\\n        }\\n        return SmartyPants($text, $attr);\\n    }\\n}\\n\\nif (!function_exists(\'SmartDashes\')) {\\n    function SmartDashes($text, $attr = null) {\\n        switch ($attr) {\\n            case 0:  return $text;\\n            case 2:  $attr = \'D\'; break;\\n            case 3:  $attr = \'i\'; break;\\n            default: $attr = \'d\'; break;\\n        }\\n        return SmartyPants($text, $attr);\\n    }\\n}\\n\\nif (!function_exists(\'SmartElipsis\')) {\\n    function SmartElipsis($text, $attr = null) {\\n        switch ($attr) {\\n            case 0:  return $text;\\n            default: $attr = \'e\'; break;\\n        }\\n        return SmartyPants($text, $attr);\\n    }\\n}\\n\\n\\nif (!function_exists(\'SmartSymbols\')) {\\n    function SmartSymbols($text, $attr = null) {\\n        switch ($attr) {\\n            case 0:  return $text;\\n            default: $attr = \'s\'; break;\\n        }\\n        return SmartyPants($text, $attr);\\n    }\\n}\\n\\n\\nif (!class_exists(\'SmartyPants_Parser\')) {\\n    #\\n    # SmartyPants Parser\\n    #\\n    \\n    class SmartyPants_Parser {\\n    \\n        # Options to specify which transformations to make:\\n        var $do_nothing   = 0;\\n        var $do_quotes    = 0;\\n        var $do_backticks = 0;\\n        var $do_dashes    = 0;\\n        var $do_ellipses  = 0;\\n        var $do_stupefy   = 0;\\n        var $convert_quot = 0; # should we translate &quot; entities into normal quotes?\\n    \\n        function SmartyPants_Parser($attr = SMARTYPANTS_ATTR) {\\n        #\\n        # Initialize a SmartyPants_Parser with certain attributes.\\n        #\\n        # Parser attributes:\\n        # 0 : do nothing\\n        # 1 : set all\\n        # 2 : set all, using old school en- and em- dash shortcuts\\n        # 3 : set all, using inverted old school en and em- dash shortcuts\\n        # \\n        # q : quotes\\n        # b : backtick quotes (``double\'\' only)\\n        # B : backtick quotes (``double\'\' and `single\')\\n        # d : dashes\\n        # D : old school dashes\\n        # i : inverted old school dashes\\n        # e : ellipses\\n        # s : symbols\\n        # w : convert &quot; entities to \\" for Dreamweaver users\\n        #\\n            if ($attr == \\"0\\") {\\n                $this->do_nothing   = 1;\\n            }\\n            else if ($attr == \\"1\\") {\\n                # Do everything, turn all options on.\\n                $this->do_quotes    = 1;\\n                $this->do_backticks = 1;\\n                $this->do_dashes    = 1;\\n                $this->do_ellipses  = 1;\\n                $this->do_symbols   = 1;\\n            }\\n            else if ($attr == \\"2\\") {\\n                # Do everything, turn all options on, use old school dash shorthand.\\n                $this->do_quotes    = 1;\\n                $this->do_backticks = 1;\\n                $this->do_dashes    = 2;\\n                $this->do_ellipses  = 1;\\n                $this->do_symbols   = 1;\\n            }\\n            else if ($attr == \\"3\\") {\\n                # Do everything, turn all options on, use inverted old school dash shorthand.\\n                $this->do_quotes    = 1;\\n                $this->do_backticks = 1;\\n                $this->do_dashes    = 3;\\n                $this->do_ellipses  = 1;\\n                $this->do_symbols   = 1;\\n            }\\n            else if ($attr == \\"-1\\") {\\n                # Special \\"stupefy\\" mode.\\n                $this->do_stupefy   = 1;\\n            }\\n            else {\\n                $chars = preg_split(\'\\/\\/\', $attr);\\n                foreach ($chars as $c){\\n                    if      ($c == \\"q\\") { $this->do_quotes    = 1; }\\n                    else if ($c == \\"b\\") { $this->do_backticks = 1; }\\n                    else if ($c == \\"B\\") { $this->do_backticks = 2; }\\n                    else if ($c == \\"d\\") { $this->do_dashes    = 1; }\\n                    else if ($c == \\"D\\") { $this->do_dashes    = 2; }\\n                    else if ($c == \\"i\\") { $this->do_dashes    = 3; }\\n                    else if ($c == \\"e\\") { $this->do_ellipses  = 1; }\\n                    else if ($c == \\"s\\") { $this->do_symbols   = 1; }\\n                    else if ($c == \\"w\\") { $this->convert_quot = 1; }\\n                    else {\\n                        # Unknown attribute option, ignore.\\n                    }\\n                }\\n            }\\n        }\\n    \\n        function transform($text) {\\n    \\n            if ($this->do_nothing) {\\n                return $text;\\n            }\\n    \\n            $tokens = $this->tokenizeHTML($text);\\n            $result = \'\';\\n            $in_pre = 0;  # Keep track of when we\'re inside <pre> or <code> tags.\\n    \\n            $prev_token_last_char = \\"\\"; # This is a cheat, used to get some context\\n                                        # for one-character tokens that consist of \\n                                        # just a quote char. What we do is remember\\n                                        # the last character of the previous text\\n                                        # token, to use as context to curl single-\\n                                        # character quote tokens correctly.\\n    \\n            foreach ($tokens as $cur_token) {\\n                if ($cur_token[0] == \\"tag\\") {\\n                    # Don\'t mess with quotes inside tags.\\n                    $result .= $cur_token[1];\\n                    if (preg_match(\'@<(\\/?)(?:\'.SMARTYPANTS_TAGS_TO_SKIP.\')[\\\\s>]@\', $cur_token[1], $matches)) {\\n                        $in_pre = isset($matches[1]) && $matches[1] == \'\\/\' ? 0 : 1;\\n                    }\\n                } else {\\n                    $t = $cur_token[1];\\n                    $last_char = substr($t, -1); # Remember last char of this token before processing.\\n                    if (! $in_pre) {\\n                        $t = $this->educate($t, $prev_token_last_char);\\n                    }\\n                    $prev_token_last_char = $last_char;\\n                    $result .= $t;\\n                }\\n            }\\n    \\n            return $result;\\n        }\\n    \\n    \\n        function educate($t, $prev_token_last_char) {\\n            $t = $this->processEscapes($t);\\n    \\n            if ($this->convert_quot) {\\n                $t = preg_replace(\'\\/&quot;\\/\', \'\\"\', $t);\\n            }\\n    \\n            if ($this->do_dashes) {\\n                if ($this->do_dashes == 1) $t = $this->educateDashes($t);\\n                if ($this->do_dashes == 2) $t = $this->educateDashesOldSchool($t);\\n                if ($this->do_dashes == 3) $t = $this->educateDashesOldSchoolInverted($t);\\n            }\\n    \\n            if ($this->do_ellipses) $t = $this->educateEllipses($t);\\n    \\n            if ($this->do_symbols) $t = $this->educateSymbols($t);\\n    \\n            # Note: backticks need to be processed before quotes.\\n            if ($this->do_backticks) {\\n                $t = $this->educateBackticks($t);\\n                if ($this->do_backticks == 2) $t = $this->educateSingleBackticks($t);\\n            }\\n    \\n            if ($this->do_quotes) {\\n                if ($t == \\"\'\\") {\\n                    # Special case: single-character \' token\\n                    if (preg_match(\'\\/\\\\S\\/\', $prev_token_last_char)) {\\n                        $t = \\"&#8217;\\";\\n                    }\\n                    else {\\n                        $t = \\"&#8216;\\";\\n                    }\\n                }\\n                else if ($t == \'\\"\') {\\n                    # Special case: single-character \\" token\\n                    if (preg_match(\'\\/\\\\S\\/\', $prev_token_last_char)) {\\n                        $t = \\"&#8221;\\";\\n                    }\\n                    else {\\n                        $t = \\"&#8220;\\";\\n                    }\\n                }\\n                else {\\n                    # Normal case:\\n                    $t = $this->educateQuotes($t);\\n                }\\n            }\\n    \\n            if ($this->do_stupefy) $t = $this->stupefyEntities($t);\\n            \\n            return $t;\\n        }\\n    \\n    \\n        function educateQuotes($_) {\\n        #\\n        #   Parameter:  String.\\n        #\\n        #   Returns:    The string, with \\"educated\\" curly quote HTML entities.\\n        #\\n        #   Example input:  \\"Isn\'t this fun?\\"\\n        #   Example output: &#8220;Isn&#8217;t this fun?&#8221;\\n        #\\n            # Make our own \\"punctuation\\" character class, because the POSIX-style\\n            # [:PUNCT:] is only available in Perl 5.6 or later:\\n            $punct_class = \\"[!\\\\\\"#\\\\\\\\$\\\\\\\\%\'()*+,-.\\\\\\\\\\/:;<=>?\\\\\\\\@\\\\\\\\[\\\\\\\\\\\\\\\\\\\\]\\\\\\\\^_`{|}~]\\";\\n    \\n            # Special case if the very first character is a quote\\n            # followed by punctuation at a non-word-break. Close the quotes by brute force:\\n            $_ = preg_replace(\\n                array(\\"\\/^\'(?=$punct_class\\\\\\\\B)\\/\\", \\"\\/^\\\\\\"(?=$punct_class\\\\\\\\B)\\/\\"),\\n                array(\'&#8217;\',                 \'&#8221;\'), $_);\\n    \\n    \\n            # Special case for double sets of quotes, e.g.:\\n            #   <p>He said, \\"\'Quoted\' words in a larger quote.\\"<\\/p>\\n            $_ = preg_replace(\\n                array(\\"\\/\\\\\\"\'(?=\\\\w)\\/\\",    \\"\\/\'\\\\\\"(?=\\\\w)\\/\\"),\\n                array(\'&#8220;&#8216;\', \'&#8216;&#8220;\'), $_);\\n    \\n            # Special case for decade abbreviations (the \'80s):\\n            $_ = preg_replace(\\"\\/\'(?=\\\\\\\\d{2}s)\\/\\", \'&#8217;\', $_);\\n    \\n            $close_class = \'[^\\\\ \\\\t\\\\r\\\\n\\\\[\\\\{\\\\(\\\\-]\';\\n            $dec_dashes = \'&\\\\#8211;|&\\\\#8212;\';\\n    \\n            # Get most opening single quotes:\\n            $_ = preg_replace(\\"{\\n                (\\n                    \\\\\\\\s          |   # a whitespace char, or\\n                    &nbsp;      |   # a non-breaking space entity, or\\n                    --          |   # dashes, or\\n                    &[mn]dash;  |   # named dash entities\\n                    $dec_dashes |   # or decimal entities\\n                    &\\\\\\\\#x201[34];    # or hex\\n                )\\n                \'                   # the quote\\n                (?=\\\\\\\\w)              # followed by a word character\\n                }x\\", \'\\\\1&#8216;\', $_);\\n            # Single closing quotes:\\n            $_ = preg_replace(\\"{\\n                ($close_class)?\\n                \'\\n                (?(1)|          # If $1 captured, then do nothing;\\n                  (?=\\\\\\\\s | s\\\\\\\\b)  # otherwise, positive lookahead for a whitespace\\n                )               # char or an \'s\' at a word ending position. This\\n                                # is a special case to handle something like:\\n                                # \\\\\\"<i>Custer<\\/i>\'s Last Stand.\\\\\\"\\n                }xi\\", \'\\\\1&#8217;\', $_);\\n    \\n            # Any remaining single quotes should be opening ones:\\n            $_ = str_replace(\\"\'\\", \'&#8216;\', $_);\\n    \\n    \\n            # Get most opening double quotes:\\n            $_ = preg_replace(\\"{\\n                (\\n                    \\\\\\\\s          |   # a whitespace char, or\\n                    &nbsp;      |   # a non-breaking space entity, or\\n                    --          |   # dashes, or\\n                    &[mn]dash;  |   # named dash entities\\n                    $dec_dashes |   # or decimal entities\\n                    &\\\\\\\\#x201[34];    # or hex\\n                )\\n                \\\\\\"                   # the quote\\n                (?=\\\\\\\\w)              # followed by a word character\\n                }x\\", \'\\\\1&#8220;\', $_);\\n    \\n            # Double closing quotes:\\n            $_ = preg_replace(\\"{\\n                ($close_class)?\\n                \\\\\\"\\n                (?(1)|(?=\\\\\\\\s))   # If $1 captured, then do nothing;\\n                                   # if not, then make sure the next char is whitespace.\\n                }x\\", \'\\\\1&#8221;\', $_);\\n    \\n            # Any remaining quotes should be opening ones.\\n            $_ = str_replace(\'\\"\', \'&#8220;\', $_);\\n    \\n            return $_;\\n        }\\n    \\n    \\n        function educateBackticks($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with ``backticks\'\' -style double quotes\\n        #               translated into HTML curly quote entities.\\n        #\\n        #   Example input:  ``Isn\'t this fun?\'\'\\n        #   Example output: &#8220;Isn\'t this fun?&#8221;\\n        #\\n    \\n            $_ = str_replace(array(\\"``\\",       \\"\'\'\\",),\\n                             array(\'&#8220;\', \'&#8221;\'), $_);\\n            return $_;\\n        }\\n    \\n    \\n        function educateSingleBackticks($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with `backticks\' -style single quotes\\n        #               translated into HTML curly quote entities.\\n        #\\n        #   Example input:  `Isn\'t this fun?\'\\n        #   Example output: &#8216;Isn&#8217;t this fun?&#8217;\\n        #\\n    \\n            $_ = str_replace(array(\\"`\\",       \\"\'\\",),\\n                             array(\'&#8216;\', \'&#8217;\'), $_);\\n            return $_;\\n        }\\n    \\n    \\n        function educateDashes($_) {\\n        #\\n        #   Parameter:  String.\\n        #\\n        #   Returns:    The string, with each instance of \\"--\\" translated to\\n        #               an em-dash HTML entity.\\n        #\\n    \\n            $_ = str_replace(\'--\', \'&#8212;\', $_);\\n            return $_;\\n        }\\n    \\n    \\n        function educateDashesOldSchool($_) {\\n        #\\n        #   Parameter:  String.\\n        #\\n        #   Returns:    The string, with each instance of \\"--\\" translated to\\n        #               an en-dash HTML entity, and each \\"---\\" translated to\\n        #               an em-dash HTML entity.\\n        #\\n    \\n            #                      em         en\\n            $_ = str_replace(array(\\"---\\",     \\"--\\",),\\n                             array(\'&#8212;\', \'&#8211;\'), $_);\\n            return $_;\\n        }\\n    \\n    \\n        function educateDashesOldSchoolInverted($_) {\\n        #\\n        #   Parameter:  String.\\n        #\\n        #   Returns:    The string, with each instance of \\"--\\" translated to\\n        #               an em-dash HTML entity, and each \\"---\\" translated to\\n        #               an en-dash HTML entity. Two reasons why: First, unlike the\\n        #               en- and em-dash syntax supported by\\n        #               EducateDashesOldSchool(), it\'s compatible with existing\\n        #               entries written before SmartyPants 1.1, back when \\"--\\" was\\n        #               only used for em-dashes.  Second, em-dashes are more\\n        #               common than en-dashes, and so it sort of makes sense that\\n        #               the shortcut should be shorter to type. (Thanks to Aaron\\n        #               Swartz for the idea.)\\n        #\\n    \\n            #                      en         em\\n            $_ = str_replace(array(\\"---\\",     \\"--\\",),\\n                             array(\'&#8211;\', \'&#8212;\'), $_);\\n            return $_;\\n        }\\n    \\n    \\n        function educateEllipses($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with each instance of \\"...\\" translated to\\n        #               an ellipsis HTML entity. Also converts the case where\\n        #               there are spaces between the dots.\\n        #\\n        #   Example input:  Huh...?\\n        #   Example output: Huh&#8230;?\\n        #\\n    \\n            $_ = str_replace(array(\\"...\\",     \\". . .\\",), \'&#8230;\', $_);\\n            return $_;\\n        }\\n\\n\\n        function educateSymbols($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with each instance of \\"(c)\\", \\"(r)\\" and \\"(tm)\\" translated to\\n        #               a \\u00a9, \\u00ae, \\u2122 and \\u00b0 HTML entities.\\n        #\\n        #   Example input:  (c)2015. All rights reserved.\\n        #   Example output: &#169;2015. All rights reserved.\\n        #\\n    \\n            $_ = str_replace(array(\\"(c)\\",   \\"(r)\\",   \\"(tm)\\",    \\"(deg)\\"),\\n                             array(\'&#169;\',\'&#174;\',\'&#8482;\', \'&#176;\'), $_);\\n            return $_;\\n        }\\n    \\n    \\n        function stupefyEntities($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with each SmartyPants HTML entity translated to\\n        #               its ASCII counterpart.\\n        #\\n        #   Example input:  &#8220;Hello &#8212; world.&#8221;\\n        #   Example output: \\"Hello -- world.\\"\\n        #\\n    \\n                                #  en-dash    em-dash\\n            $_ = str_replace(array(\'&#8211;\', \'&#8212;\'),\\n                             array(\'-\',       \'--\'), $_);\\n    \\n            # single quote         open       close\\n            $_ = str_replace(array(\'&#8216;\', \'&#8217;\'), \\"\'\\", $_);\\n    \\n            # double quote         open       close\\n            $_ = str_replace(array(\'&#8220;\', \'&#8221;\'), \'\\"\', $_);\\n    \\n            $_ = str_replace(\'&#8230;\', \'...\', $_); # ellipsis\\n    \\n            return $_;\\n        }\\n    \\n    \\n        function processEscapes($_) {\\n        #\\n        #   Parameter:  String.\\n        #   Returns:    The string, with after processing the following backslash\\n        #               escape sequences. This is useful if you want to force a \\"dumb\\"\\n        #               quote or other character to appear.\\n        #\\n        #               Escape  Value\\n        #               ------  -----\\n        #               \\\\\\\\      &#92;\\n        #               \\\\\\"      &#34;\\n        #               \\\\\'      &#39;\\n        #               \\\\.      &#46;\\n        #               \\\\-      &#45;\\n        #               \\\\`      &#96;\\n        #\\n            $_ = str_replace(\\n                array(\'\\\\\\\\\\\\\\\\\',  \'\\\\\\"\',    \\"\\\\\'\\",    \'\\\\.\',    \'\\\\-\',    \'\\\\`\'),\\n                array(\'&#92;\', \'&#34;\', \'&#39;\', \'&#46;\', \'&#45;\', \'&#96;\'), $_);\\n    \\n            return $_;\\n        }\\n    \\n    \\n        function tokenizeHTML($str) {\\n        #\\n        #   Parameter:  String containing HTML markup.\\n        #   Returns:    An array of the tokens comprising the input\\n        #               string. Each token is either a tag (possibly with nested,\\n        #               tags contained therein, such as <a href=\\"<MTFoo>\\">, or a\\n        #               run of text between tags. Each element of the array is a\\n        #               two-element array; the first is either \'tag\' or \'text\';\\n        #               the second is the actual value.\\n        #\\n        #\\n        #   Regular expression derived from the _tokenize() subroutine in \\n        #   Brad Choate\'s MTRegex plugin.\\n        #   <http:\\/\\/www.bradchoate.com\\/past\\/mtregex.php>\\n        #\\n            $index = 0;\\n            $tokens = array();\\n    \\n            $match = \'(?s:<!--.*?-->)|\'.    # comment\\n                     \'(?s:<\\\\?.*?\\\\?>)|\'.     # processing instruction\\n                                            # regular tags\\n                     \'(?:<[\\/!$]?[-a-zA-Z0-9:]+\\\\b(?>[^\\"\\\\\'>]+|\\"[^\\"]*\\"|\\\\\'[^\\\\\']*\\\\\')*>)\'; \\n    \\n            $parts = preg_split(\\"{($match)}\\", $str, -1, PREG_SPLIT_DELIM_CAPTURE);\\n    \\n            foreach ($parts as $part) {\\n                if (++$index % 2 && $part != \'\') \\n                    $tokens[] = array(\'text\', $part);\\n                else\\n                    $tokens[] = array(\'tag\', $part);\\n            }\\n            return $tokens;\\n        }\\n    \\n    }\\n}\\n\\n\\n\\/*\\n\\nPHP SmartyPants\\n===============\\n\\nDescription\\n-----------\\n\\nThis is a PHP translation of the original SmartyPants quote educator written in\\nPerl by John Gruber.\\n\\nSmartyPants is a web publishing utility that translates plain ASCII\\npunctuation characters into \\"smart\\" typographic punctuation HTML\\nentities. SmartyPants can perform the following transformations:\\n\\n*   Straight quotes (`\\"` and `\'`) into \\"curly\\" quote HTML entities\\n*   Backticks-style quotes (` ``like this\'\' `) into \\"curly\\" quote HTML \\n    entities\\n*   Dashes (`--` and `---`) into en- and em-dash entities\\n*   Three consecutive dots (`...`) into an ellipsis entity\\n\\nSmartyPants does not modify characters within `<pre>`, `<code>`, `<kbd>`, \\n`<script>`, or `<math>` tag blocks. Typically, these tags are used to \\ndisplay text where smart quotes and other \\"smart punctuation\\" would not \\nbe appropriate, such as source code or example markup.\\n\\n\\n### Backslash Escapes ###\\n\\nIf you need to use literal straight quotes (or plain hyphens and\\nperiods), SmartyPants accepts the following backslash escape sequences\\nto force non-smart punctuation. It does so by transforming the escape\\nsequence into a decimal-encoded HTML entity:\\n\\n    Escape  Value  Character\\n    ------  -----  ---------\\n      \\\\\\\\    &#92;    \\\\\\n      \\\\\\"    &#34;    \\"\\n      \\\\\'    &#39;    \'\\n      \\\\.    &#46;    .\\n      \\\\-    &#45;    -\\n      \\\\`    &#96;    `\\n\\nThis is useful, for example, when you want to use straight quotes as\\nfoot and inch marks: 6\'2\\" tall; a 17\\" iMac.\\n\\n\\nBugs\\n----\\n\\nTo file bug reports or feature requests (other than topics listed in the\\nCaveats section above) please send email to:\\n\\n<michel.fortin@michelf.com>\\n\\nIf the bug involves quotes being curled the wrong way, please send example\\ntext to illustrate.\\n\\n\\n### Algorithmic Shortcomings ###\\n\\nOne situation in which quotes will get curled the wrong way is when\\napostrophes are used at the start of leading contractions. For example:\\n\\n    \'Twas the night before Christmas.\\n\\nIn the case above, SmartyPants will turn the apostrophe into an opening\\nsingle-quote, when in fact it should be a closing one. I don\'t think\\nthis problem can be solved in the general case -- every word processor\\nI\'ve tried gets this wrong as well. In such cases, it\'s best to use the\\nproper HTML entity for closing single-quotes (`&#8217;`) by hand.\\n\\n\\nVersion History\\n---------------\\n\\n1.5.1f (23 Jan 2013):\\n\\n*   Fixed handling of HTML comments to match latest HTML specs instead of\\n    doing it the old SGML way.\\n\\n*   Lowered WordPress filtering priority to avoid clashing with the \\n    [caption] tag filter. Thanks to Mehdi Kabab for the fix.\\n\\n\\n1.5.1oo (19 May 2006)\\n\\n*   Converted SmartyPants to a object-oriented design.\\n\\n\\n1.5.1e (9 Dec 2005)\\n\\n*   Corrected a bug that prevented special characters from being \\n    escaped.\\n\\n\\n1.5.1d (25 May 2005)\\n\\n*   Corrected a small bug in `_TokenizeHTML` where a Doctype declaration\\n    was not seen as HTML (smart quotes where applied inside).\\n\\n\\n1.5.1c (13 Dec 2004)\\n\\n*   Changed a regular expression in `_TokenizeHTML` that could lead to\\n    a segmentation fault with PHP 4.3.8 on Linux.\\n\\n\\n1.5.1b (6 Sep 2004)\\n\\n*   Corrected a problem with quotes immediately following a dash\\n    with no space between: `Text--\\"quoted text\\"--text.`\\n    \\n*   PHP SmartyPants can now be used as a modifier by the Smarty \\n    template engine. Rename the file to \\"modifier.smartypants.php\\"\\n    and put it in your smarty plugins folder.\\n\\n*   Replaced a lot of space characters by tabs, saving about 4 KB.\\n\\n\\n1.5.1a (30 Jun 2004)\\n\\n*   PHP Markdown and PHP Smartypants now share the same `_TokenizeHTML` \\n    function when loaded simultanously.\\n\\n*   Changed the internals of `_TokenizeHTML` to lower the PHP version\\n    requirement to PHP 4.0.5.\\n\\n\\n1.5.1 (6 Jun 2004)\\n\\n*   Initial release of PHP SmartyPants, based on version 1.5.1 of the \\n    original SmartyPants written in Perl.\\n\\n\\nAuthor\\n------\\n\\nOriginal SmartyPants by John Gruber\\n<http:\\/\\/daringfireball.net\\/>\\n\\nPHP Port by Michel Fortin\\n<http:\\/\\/www.michelf.com\\/>\\n\\n\\nAdditional Credits\\n------------------\\n\\nPortions of this plug-in are based on Brad Choate\'s nifty MTRegex plug-in.\\nBrad Choate also contributed a few bits of source code to this plug-in.\\nBrad Choate is a fine hacker indeed. (<http:\\/\\/bradchoate.com\\/>)\\n\\nJeremy Hedley (<http:\\/\\/antipixel.com\\/>) and Charles Wiltgen\\n(<http:\\/\\/playbacktime.com\\/>) deserve mention for exemplary beta testing of \\nthe orignal SmartyPants.\\n\\n\\nCopyright and License\\n---------------------\\n\\nCopyright (c) 2003 John Gruber  \\n<http:\\/\\/daringfireball.net\\/>  \\nAll rights reserved.\\n\\nCopyright (c) 2004-2006 Michel Fortin  \\n<http:\\/\\/www.michelf.com>\\n\\nRedistribution and use in source and binary forms, with or without\\nmodification, are permitted provided that the following conditions are met:\\n\\n*   Redistributions of source code must retain the above copyright\\n    notice, this list of conditions and the following disclaimer.\\n\\n*   Redistributions in binary form must reproduce the above copyright\\n    notice, this list of conditions and the following disclaimer in the\\n    documentation and\\/or other materials provided with the distribution.\\n\\n*   Neither the name \\"SmartyPants\\" nor the names of its contributors may\\n    be used to endorse or promote products derived from this software\\n    without specific prior written permission.\\n\\nThis software is provided by the copyright holders and contributors \\"as is\\"\\nand any express or implied warranties, including, but not limited to, the \\nimplied warranties of merchantability and fitness for a particular purpose \\nare disclaimed. In no event shall the copyright owner or contributors be \\nliable for any direct, indirect, incidental, special, exemplary, or \\nconsequential damages (including, but not limited to, procurement of \\nsubstitute goods or services; loss of use, data, or profits; or business \\ninterruption) however caused and on any theory of liability, whether in \\ncontract, strict liability, or tort (including negligence or otherwise) \\narising in any way out of the use of this software, even if advised of the\\npossibility of such damage.\\n\\n*\\/\\n\\n\\nreturn SmartyPants($output,$attr = SMARTYPANTS_ATTR);"}',
        'guid' => '6fe2236809cff0771b373d1b5e627952',
        'native_key' => NULL,
        'signature' => '58cab1373254f287d98064ceda378a90',
      ),
    ),
  ),
  'related_object_attributes' => 
  array (
    'Children' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 
      array (
        0 => 'parent',
        1 => 'category',
      ),
    ),
    'Snippets' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Chunks' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Templates' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'templatename',
    ),
    'TemplateVars' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Plugins' => 
    array (
      'unique_key' => 'name',
      'preserve_keys' => false,
      'update_object' => true,
      'related_objects' => true,
      'related_object_attributes' => 
      array (
        'PluginEvents' => 
        array (
          'preserve_keys' => true,
          'update_object' => false,
          'unique_key' => 
          array (
            0 => 'pluginid',
            1 => 'event',
          ),
        ),
      ),
    ),
  ),
  'namespace' => 'typography',
  'resolve' => 
  array (
    0 => 
    array (
      'type' => 'file',
      'body' => '{"source":"typography-1.0.0-pl\\/modCategory\\/9dc74e56a1165f6cf9bb530cc19932aa\\/0\\/","target":"return MODX_CORE_PATH . \'components\\/\';","name":"typography"}',
    ),
  ),
  'validate' => NULL,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => '231eac94ec535af985fc2e6ec5fe9f47',
  'package' => 'modx',
  'class' => 'modCategory',
  'signature' => '9dc74e56a1165f6cf9bb530cc19932aa',
  'native_key' => NULL,
  'object' => '{"id":null,"parent":0,"category":"Typography"}',
);